#!/usr/bin/env python

"""Homework-07 by student Vitalii Zaitsev
"""

__author__ = "Зайцев Виталий Владимирович, Vitalii Zaitsev"
__copyright__ = "Copyright 2020"
__license__ = "GPL"
__version__ = "1.0.0"
__maintainer__ = "Vitalii Zaitsev"
__email__ = "vvzaisev79@gmail.com"
__status__ = "Education"


# Урок 7. ООП. Продвинутый уровень
# 1. Реализовать класс Matrix (матрица).
# Обеспечить перегрузку конструктора класса (метод __init__()),
# который должен принимать данные (список списков) для формирования матрицы.
# Подсказка: матрица — система некоторых математических величин, расположенных в виде прямоугольной схемы.
# Примеры матриц вы найдете в методичке.
# Следующий шаг — реализовать перегрузку метода __str__() для вывода матрицы в привычном виде.
# Далее реализовать перегрузку метода __add__() для реализации операции сложения двух объектов класса Matrix (двух матриц).
# Результатом сложения должна быть новая матрица.
# Подсказка: сложение элементов матриц выполнять поэлементно —
# первый элемент первой строки первой матрицы складываем с первым элементом первой строки второй матрицы и т.д.

# class Matrix:
#     def __init__(self, matrix):
#         self.matrix = matrix
#
#     def __str__(self):
#         # Лёгкое intro
#         intro_str = 'Ваша матрица:'+'\n'
#         # Обходим матрицу, порядно формируем строки, склеиваем в одну итоговую строку
#         result_str = intro_str
#         for i in range(len(self.matrix)):
#             result_row = ''
#             for j in range(len(self.matrix[0])):
#                 result_row = result_row + ' ' + str(self.matrix[i][j])
#             result_str = result_str + result_row + '\n'
#         return result_str
#
#     def __add__(self, other):
#         # Очень простая, "лобовая" проверка - если матрицы сравнимы, то складываем.
#         # Иначе просто говорим, что матрицы несравнимы.
#         if len(self.matrix) == len(other.matrix) and len(self.matrix[0]) == len(other.matrix[0]):
#             result = []
#             for i in range(len(self.matrix)):
#                 result_row_list = []
#                 for j in range(len(self.matrix[0])):
#                     element = self.matrix[i][j] + other.matrix[i][j]
#                     result_row_list.append(element)
#                 result.append(result_row_list)
#             return Matrix(result)
#         else:
#             return "Матрицы несравнимы, сложение невозможно"
#
#
# # Либо Вариант 1, либо Вариант 2
# # Вариант 1: размерности матриц равны
# # matrix_1 = Matrix([[1, 2], [3, 4]])
# # matrix_2 = Matrix([[10, 20], [30, 40]])
#
# # Вариант 2: размерности матриц НЕ равны
# matrix_1 = Matrix([[1, 2], [3, 4], [5, 6]])
# matrix_2 = Matrix([[10, 20], [30, 40]])
#
# print(matrix_1)
# print(matrix_1 + matrix_2)


# --------------------------------------------------------------------------------------------------------------------
# 2. Реализовать проект расчета суммарного расхода ткани на производство одежды.
# Основная сущность (класс) этого проекта — одежда, которая может иметь определенное название.
# К типам одежды в этом проекте относятся пальто и костюм.
# У этих типов одежды существуют параметры: размер (для пальто) и рост (для костюма).
# Это могут быть обычные числа: V и H, соответственно.
# Для определения расхода ткани по каждому типу одежды использовать формулы:
# для пальто (V/6.5 + 0.5), для костюма (2 * H + 0.3).
# Проверить работу этих методов на реальных данных.
# Реализовать общий подсчет расхода ткани.
# Проверить на практике полученные на этом уроке знания:
# реализовать абстрактные классы для основных классов проекта, проверить на практике работу декоратора @property.

# from abc import ABC, abstractmethod
#
# # Абстрактный класс
# class Clothing(ABC):
#     @abstractmethod
#     def calculate(self):
#         pass
#
#
# # Конкретный класс Пальто
# class Coat(Clothing):
#
#     def __init__(self, V):
#         self.V = V
#
#     # создаем свойство Размер
#     @property
#     def V(self):
#         return self.__V
#
#     # Только диапазон 50-54
#     @V.setter
#     def V(self, V):
#         if V < 50:
#             self.__V = 50
#         elif V > 54:
#             self.__V = 54
#         else:
#             self.__V = V
#
#     # Расчёт расхода ткани для пальто
#     def calculate(self):
#         return round(self.V/6.5 + 0.5)
#
#
# # Конкретный класс Костюм
# class Suit(Clothing):
#     def __init__(self, H):
#         self.H = H
#
#     # создаем свойство Рост
#     @property
#     def H(self):
#         return self.__H
#
#     # Только диапазон 160-186
#     @H.setter
#     def H(self, H):
#         if H < 160:
#             self.__H = 160
#         elif H > 186:
#             self.__H = 186
#         else:
#             self.__H = H
#
#     # Расчёт расхода ткани для костюма
#     def calculate(self):
#         return round(2 * self.H + 0.3)
#
#
# # Валидные значения
# size = 52
# print(f"Расход ткани для костюма {size}-размера составляет {Coat(size).calculate()}")
# height = 176
# print(f"Расход ткани для костюма {height}-роста составляет {Suit(height).calculate()}")
#
# # НЕвалидные значения
# myCoat = Coat(45)
# print(f"Расход ткани для пальто {45}-размера составляет {myCoat.calculate()}, "
#       f"потому что на самом деле будет пошито пальто {myCoat.V}-размера")
# mySuit = Suit(200)
# print(f"Расход ткани для костюма {200}-роста составляет {mySuit.calculate()}, "
#       f"потому что на самом деле будет пошит костюм {mySuit.H}-роста")


# --------------------------------------------------------------------------------------------------------------------
# 3. Реализовать программу работы с органическими клетками.
# Необходимо создать класс Клетка.
# В его конструкторе инициализировать параметр, соответствующий количеству клеток (целое число).
# В классе должны быть реализованы методы перегрузки арифметических операторов:
# сложение (__add__()), вычитание (__sub__()),
# умножение (__mul__()), деление (__truediv__()).
# Данные методы должны применяться только к клеткам и выполнять
# увеличение, уменьшение, умножение и обычное (не целочисленное) деление клеток, соответственно.
# В методе деления должно осуществляться округление значения до целого числа.

# Сложение. Объединение двух клеток. При этом число ячеек общей клетки должно равняться сумме ячеек исходных двух клеток.

# Вычитание. Участвуют две клетки. Операцию необходимо выполнять только если разность количества ячеек двух клеток больше нуля,
# иначе выводить соответствующее сообщение.

# Умножение. Создается общая клетка из двух.
# Число ячеек общей клетки определяется как произведение количества ячеек этих двух клеток.

# Деление. Создается общая клетка из двух.
# Число ячеек общей клетки определяется как целочисленное деление количества ячеек этих двух клеток.

# В классе необходимо реализовать метод make_order(), принимающий экземпляр класса и количество ячеек в ряду.
# Данный метод позволяет организовать ячейки по рядам.
# Метод должен возвращать строку вида *****\n*****\n*****..., где количество ячеек между \n равно переданному аргументу.
# Если ячеек на формирование ряда не хватает, то в последний ряд записываются все оставшиеся.
# Например, количество ячеек клетки равняется 12, количество ячеек в ряду — 5.
# Тогда метод make_order() вернет строку: *****\n*****\n**.
# Или, количество ячеек клетки равняется 15, количество ячеек в ряду — 5.
# Тогда метод make_order() вернет строку: *****\n*****\n*****.

# class Cell:
#     def __init__(self, cell):
#         self.cell = int(abs(cell))
#
#     def __str__(self):
#         return str(self.cell)
#
#     def __add__(self, other):
#         return self.cell + other.cell
#
#     def __sub__(self, other):
#         result = self.cell - other.cell
#         if result < 0:
#             return "Операция невозможна"
#         else:
#             return result
#
#     def __mul__(self, other):
#         return self.cell * other.cell
#
#     def __floordiv__(self, other):
#         return self.cell // other.cell
#
#     def make_order(self, required_cell_count_in_the_row):
#         # целочисленное деление - количество полных рядов
#         actual_rows = self.cell // required_cell_count_in_the_row
#         # остаток от деления - количество оставшихся клеток в неполном ряду
#         reminder = self.cell % required_cell_count_in_the_row
#
#         # печать
#         i = 0
#         while i < actual_rows:
#             print('*'*required_cell_count_in_the_row)
#             i += 1
#         if reminder > 0:
#             print('*'*reminder)
#
#
# myCell_1 = Cell(10)
# myCell_2 = Cell(4)
#
# print(f"myCell_1 {myCell_1} + myCell_2 {myCell_2} = {myCell_1 + myCell_2}")
# print(f"myCell_1 {myCell_1} - myCell_2 {myCell_2} = {myCell_1 - myCell_2}")
# print(f"myCell_1 {myCell_1} * myCell_2 {myCell_2} = {myCell_1 * myCell_2}")
# print(f"myCell_1 {myCell_1} // myCell_2 {myCell_2} = {myCell_1 // myCell_2}")
#
# print(F"myCell_1 {myCell_1}: по трое в ряд: ")
# myCell_1.make_order(3)
#
# print(F"myCell_1 {myCell_1}: по 5 в ряд: ")
# myCell_1.make_order(5)
#
# print(F"myCell_1 {myCell_1}: колонной по одному: ")
# myCell_1.make_order(1)
#
# print(F"myCell_1 {myCell_1}: в одну шеренгу: ")
# myCell_1.make_order(10)
